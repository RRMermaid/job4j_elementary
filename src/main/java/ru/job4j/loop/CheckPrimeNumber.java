package ru.job4j.loop;

import java.lang.*;

public class CheckPrimeNumber {
    /**
     * Метод проверки числа на простоту. Описание алгоритма.
     * Сначала мы считаем все числа меньше 2 не простыми и с порога вводим им статус false.
     * Затем исключили перебор для четных чисел, так как они не простые, кроме исключения в виде 2
     * Остается проверить нечетное число
     * Нам достаточно проверить делители до квадратного корня из проверяемого числа,
     * потому что число, являющееся вторым множителем в составном числе,
     * всегда первым будет иметь число, меньшее квадратного корня.
     * Наихудший случай по стоимости перебора тогда будет либо в случае,
     * когда число является полным квадратом, либо простым числом.
     * Вычисление квадратного корня вынесено в инициализационную часть цикла, которая вычисляется только один раз,
     * для обеспечеения требования отсутствия промежуточной переменной,
     * и дополнено математикой получения ближайшего наибольшего нечетного числа.
     * Число, делящееся нацело на четный делитель, само должно быть четным
     * По этой причине мы не тратим процессор на четные делители в этой ветке и поэтому финишируем на 3
     * Код мог быть проще, если бы мы не были обязаны поддерживать сквозную переменную prime.
     * Сквозные переменные - это как глобальные переменные.
     *
     * @param number число, которое нужно проверить на простоту
     * @return будет true, если число простое.
     */
    public static boolean check(int number) {
        boolean prime = (number > 1);
        if ((number & 1) == 0) {
            prime = (number == 2);
        } else {
            for (int index = (int) Math.round((Math.sqrt(number) + 1.0) / 2.0) * 2 - 1; index >= 3; index -= 2) {
                if (number % index == 0) {
                    prime = false;
                    break;
                }
            }
        }
        return prime;
    }
}