package ru.job4j.loop;

import java.lang.*;

public class CheckPrimeNumber {
    public static boolean check(int number) {
         /*Считаем все числа меньше 2 не простыми и с порога вводим им статус false.
    Можно было бы сделать ранний возврат, но увы, правила игры требуют более кривого кода.
    prime = true, если число простое
    prime = false в остальных случаях
    */
        boolean prime = (number > 1);
        /* Наложили битную маску 0x1 в помощью битового AND,
           получили последний бит числа для выявления четности числа: */
        if ((number & 1) == 0) { /* Исключили перебор для четных чисел, так как они не простые */
            prime = (number == 2); /* оставляем исключение только для числа 2 (это единственное простое четное число) */
        } else { /* Остается проверить нечетное число */
        /*Нам достаточно проверить делители до квадратного корня из проверяемого числа,
        потому что число, являющееся вторым множителдем в составном числе,
        всегда первым будет иметь число, меньшее квадратного корня7
        Наихудщий случай по стоимости перебора тогда будет либо в случае,
        когда число является полным квадратом или простым числом.
        Чем большее число подано на вход,
        тем больше порядков составит экономия процессорного времени на принятии решения о простоте числа.
        Корень вычисляется как double в силу спецификации библиотечной функции,
        Поэтому мы завели переменную, в которую мы кастуем результат к целочисленному инту,
        тем самым, по сути, ограничиваясь ближайшим полным квадратным корнем.
        Если не завести эту переменную, то в дальнейшем операция сравнения инта и дабла
        будет на каждой итерации цикла неявно делать каст типа, чтобы провести целочисленное сравнение,
        что приведет к нерациональному расходу процессорного времени. */
            int sqrt = ((int) Math.sqrt(number));
            /* Четные делители исключены, так как включают в себя 2 в роли делителя
               Число, делящееся нацело на четный делитель, само должно быть четным
               По этой причине мы не тратим процессор на четные делители в этой ветке и поэтому стартуем с 3*/
            for (int index = 3; index <= sqrt; index += 2) { // 3, 5, 7, 9, 11, ...
                if (number % index == 0) { /* остаток от целочисленного деления 0 */
                    prime = false; /* ставим признак составного числа */
                    break; /* завершаем цикл поиска делителя составного числа */
                }
            }
        }
        /* Код мог быть проще, если бы мы не были обязаны поддерживать сквозную переменную prime. Сквозные переменные -
        это как глобальные переменные. Даешь отказ от практики ранних возвратов в массы! Больше багов, хороших и разных! */
        return prime;
    }
}